# 生活优选服务平台
  该项目是一款智能化生活服务平台，支持用户点评与商品采购快送，采用前后端分离架构，本仓库中是后端项目。平台功能涵盖商品快送、优惠券秒杀、好物分享、好友关注、粉丝推送等。
相比于市面上普遍的点评项目，本项目将消息队列由**Redis stream** 改造成 **RabbitMQ**,采用了更专业的消息队列
## 业务介绍
### 1. 优惠券秒杀
技术实现：Lua脚本 + Redisson 分布式锁
#### 在这个过程中有Redis缓存了什么内容？Lua脚本中的内容是什么？
- 将每个优惠券的库存存到Redis缓存中，根据优惠券的时效设计缓存的过期时间
- 用户下单的时候，通过运行Lua脚本，判断库存是否充足，如果缓存中该优惠券的库存充足则进行原子性的扣减。
- 同时，为了保证一人一单的效果，对于**每个优惠券在Redis中维护了下单该优惠券的用户id集合**。在用户抢购优惠券的时候，会判断用户ID是否在该优惠券对应的集合中。

之后执行完Lua脚本后，将消息投递到消息队列中异步更新MySQL并创建订单

#### 消息队列方案
1. 采用Redis Stream实现消息队列方案
创建线程池，选择一个线程做消费者异步消费订单信息，创建订单成功后确认消息
在 Redis Stream 中，使用消费者组（Consumer Group）消费消息时，Redis 会自动维护一个 Pending Entries List（简称 pending-list），它记录了：某个消费者已经读取但尚未确认（ACK）的消息；处理死信队列中的消息继续创建订单

2. 采用RabbitMQ实现消息队列
采用手动ACK的方法，如果创建订单的过程抛异常，不断重试，（重试设置时间间隔）如果3次重试失败投递到死信队列中

2. 采用RabbitMQ实现消息队列
采用手动ACK的方法，如果创建订单的过程抛异常，不断重试，（重试设置时间间隔）如果3次重试失败投递到死信队列中

#### 后续创建订单
##### 技术实现 Redisson分布式锁： 一人一单和防止库存超卖

Lua脚本 + Redission分布式锁 + 乐观锁更新MySQL库存，实现一人一单，防止库存超卖
##### 其中Redission 锁住的是什么？
源码如下：
```
RLock lock = redissonClient.getLock("lock:order:" + userId);
```
这一行通过 Redisson 的分布式锁机制，以 "lock:order:" + userId 作为锁的 key，从而**确保同一时刻只能有一个线程为该用户（userId）创建订单**。



## 2. 点评 + 粉丝推流
发布博客推送给所有粉丝
在Redis 用ZSet存用户关注者的博客id,根据业务需要设计过期时间（查看30天内博客）。发送点评， 推送给所有粉丝,存到粉丝信箱(Zset)中，Zset存储内容：博客id  权重为博客发布的时间戳。
